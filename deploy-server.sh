#!/bin/bash

# =============================================================================
# DEPLOY SCRIPT FOR LIDER GARANT
# Server: 85.198.97.62
# Domains: lider-garant.ru, www.lider-garant.ru, lk.lider-garant.ru
# =============================================================================
#
# Features:
#   - All code from YOUR repository (no external submodules)
#   - Real SSL certificates via Let's Encrypt
#   - Database preserved between deploys (Docker volume)
#   - Safe container management (no data loss)
#
# =============================================================================

set -e  # Exit on error

REPO_URL="https://github.com/Nevern1y/vashmarketolog"
PROJECT_DIR="/opt/vashmarketolog"
DOMAINS="lider-garant.ru www.lider-garant.ru lk.lider-garant.ru"
EMAIL="admin@lider-garant.ru"  # For Let's Encrypt notifications

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}=== ДЕПЛОЙ LIDER GARANT на сервер 85.198.97.62 ===${NC}"
echo ""

# =============================================================================
# Шаг 1: Установка зависимостей
# =============================================================================
echo -e "${YELLOW}Шаг 1: Проверка и установка зависимостей...${NC}"
apt update -qq

# Install git and curl only (avoid Docker package conflicts)
apt install -y git curl

# Check if Docker is already installed
if command -v docker &> /dev/null; then
    echo "Docker уже установлен: $(docker --version)"
else
    echo "Установка Docker из официального репозитория..."
    curl -fsSL https://get.docker.com | sh
fi

# Check if docker compose plugin is available
if docker compose version &> /dev/null 2>&1; then
    echo "Docker Compose уже установлен: $(docker compose version --short 2>/dev/null || echo 'OK')"
else
    echo "Установка Docker Compose plugin..."
    # Install compose plugin manually (avoid apt containerd conflict)
    DOCKER_CONFIG=${DOCKER_CONFIG:-/usr/local/lib/docker}
    mkdir -p $DOCKER_CONFIG/cli-plugins
    curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -o $DOCKER_CONFIG/cli-plugins/docker-compose
    chmod +x $DOCKER_CONFIG/cli-plugins/docker-compose
    echo "Docker Compose установлен: $(docker compose version --short 2>/dev/null || echo 'OK')"
fi

# Ensure Docker is running
systemctl enable docker 2>/dev/null || true
systemctl start docker 2>/dev/null || true

echo -e "${GREEN}✓ Зависимости установлены${NC}"
echo ""

# =============================================================================
# Шаг 2: Клонирование/обновление репозитория
# =============================================================================
echo -e "${YELLOW}Шаг 2: Синхронизация репозитория...${NC}"
if [ -d "$PROJECT_DIR/.git" ]; then
    echo "Обновление существующего репозитория..."
    cd "$PROJECT_DIR"
    git fetch origin
    git reset --hard origin/main
    git clean -fd
else
    echo "Первоначальное клонирование репозитория..."
    rm -rf "$PROJECT_DIR"
    git clone "$REPO_URL" "$PROJECT_DIR"
    cd "$PROJECT_DIR"
fi

echo -e "${GREEN}✓ Репозиторий синхронизирован${NC}"
echo ""

# =============================================================================
# Шаг 3: Создание/обновление .env файла
# =============================================================================
echo -e "${YELLOW}Шаг 3: Настройка переменных окружения...${NC}"

# Check if .env exists and has real credentials
if [ -f "$PROJECT_DIR/.env" ] && grep -q "^SECRET_KEY=" "$PROJECT_DIR/.env"; then
    echo "Используем существующий .env файл"
else
    echo "Создание .env файла..."
    # Generate secure secret key
    SECRET_KEY=$(openssl rand -base64 50 | tr -dc 'a-zA-Z0-9' | head -c 64)
    DB_PASSWORD=$(openssl rand -base64 32 | tr -dc 'a-zA-Z0-9' | head -c 32)
    
    cat > "$PROJECT_DIR/.env" << ENVEOF
# Generated by deploy-server.sh on $(date)
SECRET_KEY=$SECRET_KEY
DB_NAME=lider_garant
DB_USER=postgres
DB_PASSWORD=$DB_PASSWORD
DB_HOST=db
DB_PORT=5432
REDIS_HOST=redis
REDIS_PORT=6379
ALLOWED_HOSTS=.lider-garant.ru,lk.lider-garant.ru,85.198.97.62,localhost
CORS_ALLOWED_ORIGINS=https://lk.lider-garant.ru,https://lider-garant.ru
BANK_API_URL=https://stagebg.realistbank.ru/agent_api1_1
BANK_API_LOGIN=
BANK_API_PASSWORD=
SECURE_SSL_REDIRECT=False
ACCESS_TOKEN_LIFETIME_MINUTES=60
REFRESH_TOKEN_LIFETIME_DAYS=7
ENVEOF

    echo -e "${YELLOW}ВНИМАНИЕ: Обновите BANK_API_LOGIN и BANK_API_PASSWORD в $PROJECT_DIR/.env${NC}"
fi

echo -e "${GREEN}✓ Переменные окружения настроены${NC}"
echo ""

# =============================================================================
# Шаг 4: Проверка/получение SSL сертификатов (Let's Encrypt)
# =============================================================================
echo -e "${YELLOW}Шаг 4: Настройка SSL сертификатов...${NC}"

CERT_PATH="$PROJECT_DIR/certbot/conf/live/lider-garant.ru"

if [ -f "$CERT_PATH/fullchain.pem" ] && [ -f "$CERT_PATH/privkey.pem" ]; then
    echo "SSL сертификаты уже существуют"
    
    # Check certificate expiry
    EXPIRY=$(openssl x509 -enddate -noout -in "$CERT_PATH/fullchain.pem" 2>/dev/null | cut -d= -f2)
    echo "Срок действия сертификата: $EXPIRY"
    
    # Copy certificates for nginx (not symlinks - Docker can't follow host symlinks)
    mkdir -p "$PROJECT_DIR/nginx/ssl"
    cp -f "$CERT_PATH/fullchain.pem" "$PROJECT_DIR/nginx/ssl/fullchain.pem"
    cp -f "$CERT_PATH/privkey.pem" "$PROJECT_DIR/nginx/ssl/privkey.pem"
    chmod 644 "$PROJECT_DIR/nginx/ssl/fullchain.pem"
    chmod 600 "$PROJECT_DIR/nginx/ssl/privkey.pem"
    
    USE_SSL=true
else
    echo "SSL сертификаты не найдены. Получаем через Let's Encrypt..."
    
    # Create directories
    mkdir -p "$PROJECT_DIR/certbot/conf"
    mkdir -p "$PROJECT_DIR/certbot/www"
    mkdir -p "$PROJECT_DIR/nginx/ssl"
    
    # Stop any running nginx
    docker stop lider_prod_nginx 2>/dev/null || true
    
    # Start temporary nginx for ACME challenge
    echo "Запуск временного nginx для получения сертификата..."
    docker run -d --rm --name certbot_nginx \
        -p 80:80 \
        -v "$PROJECT_DIR/nginx/nginx-init.conf:/etc/nginx/nginx.conf:ro" \
        -v "$PROJECT_DIR/certbot/www:/var/www/certbot:ro" \
        nginx:alpine
    
    sleep 3
    
    # Get certificate from Let's Encrypt
    echo "Запрос сертификата у Let's Encrypt..."
    docker run --rm \
        -v "$PROJECT_DIR/certbot/conf:/etc/letsencrypt" \
        -v "$PROJECT_DIR/certbot/www:/var/www/certbot" \
        certbot/certbot certonly \
        --webroot \
        --webroot-path=/var/www/certbot \
        --email "$EMAIL" \
        --agree-tos \
        --no-eff-email \
        -d lider-garant.ru \
        -d www.lider-garant.ru \
        -d lk.lider-garant.ru
    
    # Stop temporary nginx
    docker stop certbot_nginx 2>/dev/null || true
    
    if [ -f "$CERT_PATH/fullchain.pem" ]; then
        echo -e "${GREEN}✓ SSL сертификаты успешно получены!${NC}"
        
        # Copy certificates for nginx (not symlinks - Docker can't follow host symlinks)
        cp -f "$CERT_PATH/fullchain.pem" "$PROJECT_DIR/nginx/ssl/fullchain.pem"
        cp -f "$CERT_PATH/privkey.pem" "$PROJECT_DIR/nginx/ssl/privkey.pem"
        chmod 644 "$PROJECT_DIR/nginx/ssl/fullchain.pem"
        chmod 600 "$PROJECT_DIR/nginx/ssl/privkey.pem"
        
        USE_SSL=true
    else
        echo -e "${RED}✗ Не удалось получить SSL сертификаты${NC}"
        echo "Проверьте, что домены lider-garant.ru, www.lider-garant.ru, lk.lider-garant.ru"
        echo "направлены на IP адрес этого сервера (85.198.97.62)"
        echo ""
        echo "Создаем временный self-signed сертификат..."
        
        openssl req -x509 -nodes -days 90 -newkey rsa:2048 \
            -keyout "$PROJECT_DIR/nginx/ssl/privkey.pem" \
            -out "$PROJECT_DIR/nginx/ssl/fullchain.pem" \
            -subj "/C=RU/ST=Moscow/L=Moscow/O=LiderGarant/OU=IT/CN=lider-garant.ru"
        
        USE_SSL=true
        echo -e "${YELLOW}Временный сертификат создан. Перезапустите скрипт после настройки DNS.${NC}"
    fi
fi

echo ""

# =============================================================================
# Шаг 5: Остановка контейнеров (БЕЗ удаления volumes!)
# =============================================================================
echo -e "${YELLOW}Шаг 5: Остановка контейнеров...${NC}"

cd "$PROJECT_DIR"

# Stop only our containers, preserve volumes (database!)
docker compose -f docker-compose.prod.yml down 2>/dev/null || true

# Note: We do NOT use "docker compose down -v" - that would delete the database!

echo -e "${GREEN}✓ Контейнеры остановлены (данные сохранены)${NC}"
echo ""

# =============================================================================
# Шаг 5.5: CLEAN DEPLOY - Полная очистка (сохраняя базу данных)
# =============================================================================
echo -e "${YELLOW}Шаг 5.5: Полная очистка для сброса браузерного кэша...${NC}"

# Сохраняем важные файлы перед очисткой
echo "Сохраняем базу данных и сертификаты..."

# Backup .env file
BACKUP_DIR="/tmp/lider_backup_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$BACKUP_DIR"

if [ -f "$PROJECT_DIR/.env" ]; then
    cp "$PROJECT_DIR/.env" "$BACKUP_DIR/.env"
    echo "  ✓ .env сохранен"
fi

# Backup SSL certificates
if [ -d "$PROJECT_DIR/certbot" ]; then
    cp -r "$PROJECT_DIR/certbot" "$BACKUP_DIR/certbot"
    echo "  ✓ SSL сертификаты сохранены"
fi

if [ -d "$PROJECT_DIR/nginx/ssl" ]; then
    mkdir -p "$BACKUP_DIR/nginx"
    cp -r "$PROJECT_DIR/nginx/ssl" "$BACKUP_DIR/nginx/ssl"
    echo "  ✓ Nginx SSL сохранен"
fi

# Получаем имя volume с базой данных (сохраняем его!)
DB_VOLUME=$(docker volume ls --format '{{.Name}}' | grep -E 'postgres_data|db_data|lider.*postgres' | head -1)
if [ -n "$DB_VOLUME" ]; then
    echo -e "  ${GREEN}✓ База данных будет сохранена в volume: $DB_VOLUME${NC}"
else
    echo -e "  ${YELLOW}⚠ Volume с базой данных не найден (возможно, первый запуск)${NC}"
fi

# Удаляем все Docker images проекта (принудительная пересборка)
echo "Удаляем Docker images проекта..."
docker images --format '{{.Repository}}:{{.Tag}}' | grep -E 'lider|vashmarketolog|landing|cabinet|backend' | xargs -r docker rmi -f 2>/dev/null || true

# Удаляем все неиспользуемые images и build cache
echo "Очищаем Docker build cache..."
docker builder prune -af 2>/dev/null || true
docker image prune -af 2>/dev/null || true

# Полностью удаляем директорию проекта (кроме volume с БД который хранится отдельно Docker'ом)
echo "Удаляем файлы проекта..."
rm -rf "$PROJECT_DIR"

# Воссоздаем директорию и клонируем репозиторий заново
echo "Клонируем свежий репозиторий..."
git clone "$REPO_URL" "$PROJECT_DIR"
cd "$PROJECT_DIR"

# Восстанавливаем сохраненные файлы
echo "Восстанавливаем конфигурацию..."

if [ -f "$BACKUP_DIR/.env" ]; then
    cp "$BACKUP_DIR/.env" "$PROJECT_DIR/.env"
    echo "  ✓ .env восстановлен"
fi

if [ -d "$BACKUP_DIR/certbot" ]; then
    cp -r "$BACKUP_DIR/certbot" "$PROJECT_DIR/certbot"
    echo "  ✓ SSL сертификаты восстановлены"
fi

if [ -d "$BACKUP_DIR/nginx/ssl" ]; then
    mkdir -p "$PROJECT_DIR/nginx"
    cp -r "$BACKUP_DIR/nginx/ssl" "$PROJECT_DIR/nginx/ssl"
    echo "  ✓ Nginx SSL восстановлен"
fi

# Удаляем временный backup
rm -rf "$BACKUP_DIR"

echo -e "${GREEN}✓ Чистая установка подготовлена (база данных сохранена в Docker volume)${NC}"
echo ""

# =============================================================================
# Шаг 6: Сборка и запуск
# =============================================================================
echo -e "${YELLOW}Шаг 6: Сборка и запуск контейнеров...${NC}"

docker compose -f docker-compose.prod.yml up -d --build

echo -e "${GREEN}✓ Контейнеры запущены${NC}"
echo ""

# =============================================================================
# Шаг 7: Ожидание готовности сервисов
# =============================================================================
echo -e "${YELLOW}Шаг 7: Проверка готовности сервисов...${NC}"

# Wait for services to be ready
sleep 10

# Check container status
echo ""
echo "Статус контейнеров:"
docker compose -f docker-compose.prod.yml ps

echo ""

# Test endpoints
echo "Проверка доступности:"

if curl -s -o /dev/null -w "%{http_code}" http://localhost:80 | grep -q "200\|301\|302"; then
    echo -e "${GREEN}✓ HTTP (port 80) - OK${NC}"
else
    echo -e "${YELLOW}⚠ HTTP (port 80) - проверьте логи${NC}"
fi

if curl -sk -o /dev/null -w "%{http_code}" https://localhost:443 | grep -q "200\|301\|302"; then
    echo -e "${GREEN}✓ HTTPS (port 443) - OK${NC}"
else
    echo -e "${YELLOW}⚠ HTTPS (port 443) - проверьте логи${NC}"
fi

echo ""

# =============================================================================
# Завершение
# =============================================================================
echo -e "${GREEN}=== ДЕПЛОЙ ЗАВЕРШЕН ===${NC}"
echo ""
echo "Приложение доступно по адресам:"
echo -e "  ${GREEN}https://lider-garant.ru${NC}     - Лендинг"
echo -e "  ${GREEN}https://lk.lider-garant.ru${NC}  - Личный кабинет"
echo ""
echo "Полезные команды:"
echo "  Логи:     docker compose -f docker-compose.prod.yml logs -f"
echo "  Статус:   docker compose -f docker-compose.prod.yml ps"
echo "  Рестарт:  docker compose -f docker-compose.prod.yml restart"
echo ""
echo "База данных:"
echo "  Volume 'postgres_data' сохраняется между деплоями"
echo "  Для backup: docker exec lider_prod_db pg_dump -U postgres lider_garant > backup.sql"
echo ""

# Show SSL certificate info
if [ -f "$CERT_PATH/fullchain.pem" ]; then
    EXPIRY=$(openssl x509 -enddate -noout -in "$CERT_PATH/fullchain.pem" | cut -d= -f2)
    echo "SSL сертификат действителен до: $EXPIRY"
    echo "Сертификат будет автоматически обновляться контейнером certbot"
fi
